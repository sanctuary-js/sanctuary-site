#!/usr/bin/env node

/* eslint-env node */
/* eslint max-len: ["off"] */

'use strict';

const fs                = require ('fs');
const path              = require ('path');
const vm                = require ('vm');

const Future            = require ('fluture');
const flutureTypes      = require ('fluture-sanctuary-types');
const marked            = require ('marked');
const R                 = require ('ramda');
const S_                = require ('sanctuary');
const pkg               = require ('sanctuary/package.json');
const $                 = require ('sanctuary-def');
const Descending        = require ('sanctuary-descending');
const show              = require ('sanctuary-show');
const Z                 = require ('sanctuary-type-classes');

const Html              = require ('../adt/Html');
const List              = require ('../adt/List');
const Sum               = require ('../adt/Sum');
const env_              = require ('../env');


const checkTypes        = process.env.NODE_ENV !== 'production';
const env               = env_.concat (flutureTypes.env);
const S                 = S_.create ({checkTypes, env});
const def               = $.create ({checkTypes, env});

const $Future           = flutureTypes.FutureType;
const I                 = S.I;
const Just              = S.Just;
const K                 = S.K;
const Left              = S.Left;
const Nothing           = S.Nothing;
const Right             = S.Right;
const T                 = S.T;
const ap                = S.ap;
const array             = S.array;
const bimap             = S.bimap;
const chain             = S.chain;
const compose           = S.compose;
const concat            = S.concat;
const cond              = R.cond;
const curry2            = S.curry2;
const curry3            = S.curry3;
const either            = S.either;
const eitherToFuture    = S.either (Future.reject) (Future.resolve);
const empty             = S.empty;
const encase            = S.encase;
const equals            = S.equals;
const flip              = S.flip;
const fork              = Future.fork;
const fst               = S.fst;
const get               = S.get;
const has               = R.has;
const ifElse            = S.ifElse;
const is                = S.is;
const join              = S.join;
const lift2             = S.lift2;
const lift3             = S.lift3;
const map               = S.map;
const mapLeft           = S.mapLeft;
const matchAll          = S.matchAll;
const maybe             = S.maybe;
const maybe_            = S.maybe_;
const node              = Future.node;
const of                = S.of;
const on                = S.on;
const pairs             = S.pairs;
const pipe              = S.pipe;
const prop              = S.prop;
const reduce            = S.reduce;
const regex             = S.regex;
const reject            = Future.reject;
const replace           = R.replace;
const resolve           = Future.resolve;
const snd               = S.snd;
const sort              = S.sort;
const splitOn           = S.splitOn;
const splitOnRegex      = S.splitOnRegex;
const test              = S.test;
const when              = S.when;

const ESCAPE            = '\u001B';
const NO_BREAK_SPACE    = '\u00A0';
const PILCROW_SIGN      = '\u00B6';
const ZERO_WIDTH_SPACE  = '\u200B';
const WORD_JOINER       = '\u2060';

const reset             = ESCAPE + '[0m';
const red               = ESCAPE + '[31m';
const green             = ESCAPE + '[32m';

//    a :: Type
const a = $.TypeVariable ('a');

//    fromJust :: Maybe a -> a !
const fromJust =
def ('fromJust')
    ({})
    ([$.Maybe (a), a])
    (maybe_ (() => { throw new Error ('fromJust applied to Nothing'); }) (I));

//    wrap :: Semigroup a => a -> a -> a -> a
const wrap =
def ('wrap')
    ({a: [Z.Semigroup]})
    ([a, a, a, a])
    (before => after => middle => concat (concat (before) (middle)) (after));

//    el :: String -> StrMap String -> Maybe Html -> Html
const el =
def ('el')
    ({})
    ([$.String, $.StrMap ($.String), $.Maybe (Html.Type), Html.Type])
    (tagName => attrs => html =>
       reduce (concat)
              (empty (Html))
              (join ([[Html (`<${tagName}`)],
                      chain (pair => [Html (' '),
                                      Html.encode (fst (pair)),
                                      Html ('='),
                                      Html ('"'),
                                      Html.encode (snd (pair)),
                                      Html ('"')])
                            (sort (pairs (attrs))),
                      [Html ('>')],
                      maybe ([]) (of (Array)) (html),
                      maybe ([]) (K ([Html (`</${tagName}>`)])) (html)])));

//    anchor :: String -> String -> Html
const anchor =
def ('anchor')
    ({})
    ([$.String, $.String, Html.Type])
    (href => text => el ('a') ({href}) (Just (Html.encode (text))));

//    spanClass :: String -> String -> Html
const spanClass =
def ('spanClass')
    ({})
    ([$.String, $.String, Html.Type])
    (className => text => el ('span')
                             ({class: className})
                             (Just (Html.encode (text))));

//    Version :: Type
const Version = $.NullaryType
  ('Version')
  ('')
  ([$.String])
  (test (/^\d+[.]\d+[.]\d+$/));

//    dependencyVersion :: String -> Maybe Version
const dependencyVersion =
def ('dependencyVersion')
    ({})
    ([$.String, $.Maybe (Version)])
    (name => get (is (Version)) (name) (pkg.dependencies));

//    dependencyUrl :: String -> Maybe String
const dependencyUrl =
def ('dependencyUrl')
    ({})
    ([$.String, $.Maybe ($.String)])
    (name => map (concat (`https://github.com/sanctuary-js/${name}/tree/v`))
                 (dependencyVersion (name)));

//    externalLink :: String -> String -> Html
const externalLink =
def ('externalLink')
    ({})
    ([$.String, $.String, Html.Type])
    (name => s => anchor (fromJust (dependencyUrl (name)) + '#' + s) (s));

//    linkTokens :: String -> Html
const linkTokens =
def ('linkTokens')
    ({})
    ([$.String, Html.Type])
    (cond ([[test (/^[a-z]$/),                 Html.encode],
            [equals (''),                      Html.encode],
            [equals ('=>'),                    Html.encode],
            [equals ('~>'),                    Html.encode],
            [equals ('-' + WORD_JOINER + '>'), K (Html.encode ('->'))],
            [equals ('TypeRep'),               anchor ('https://github.com/fantasyland/fantasy-land#type-representatives')],
            [flip (has) ($),                   externalLink ('sanctuary-def')],
            [flip (has) (Z),                   externalLink ('sanctuary-type-classes')],
            [K (true),                         Html.encode]]));

//    headingToMarkup :: String -> String -> String -> Html
const headingToMarkup =
def ('headingToMarkup')
    ({})
    ([$.String, $.String, $.String, Html.Type])
    (id => href => text => {
       const {t, html} = reduce
         (({t, html, ctx}) => c =>
            c === ' ' && ctx === '' ?
              {t: '', html: wrap (html) (Html.encode (c)) (anchor (href) (t)), ctx} :
            c === ':' && (ctx === '' || ctx.endsWith ('{')) ?
              {t: '', html: concat (html) (Html.encode (c)), ctx: ctx + ';'} :
            c === ':' && (ctx === ';' || ctx.endsWith ('{;')) ?
              {t: '', html: concat (html) (Html.encode (c)), ctx: ctx.slice (0, -1) + ':'} :
            c === '(' || c === '[' || c === '{' ?
              {t: '', html: wrap (html) (Html.encode (c)) (linkTokens (t)), ctx: ctx + c} :
            c === ')' || c === ']' || c === '}' ?
              {t: '', html: wrap (html) (Html.encode (c)) (linkTokens (t)), ctx: (ctx.replace (/:$/, '')).slice (0, -1)} :
            c === ',' ?
              {t: '', html: wrap (html) (Html.encode (c)) (linkTokens (t)), ctx: ctx.replace (/:$/, '')} :
            c === ' ' || c === NO_BREAK_SPACE || c === '?' ?
              {t: '', html: wrap (html) (Html.encode (c)) ((ctx.endsWith ('{') ? Html.encode : linkTokens) (t)), ctx} :
            // else
              {t: t + c, html, ctx})
         ({t: '', html: empty (Html), ctx: ''})
         (splitOn ('') (text));

       return el ('h4')
                 ({id})
                 (Just (el ('code')
                           ({})
                           (Just (concat (html) (linkTokens (t))))));
     });

//    toInputMarkup :: String -> Html
const toInputMarkup =
def ('toInputMarkup')
    ({})
    ([$.String, Html.Type])
    (value => el ('input') ({value}) (Nothing));

//    $context :: ContextifiedSandbox
const $context = (() => {
  const {Nil, Cons} = List;
  const S = Object.assign (S_.create ({checkTypes: true, env}),
                           {env: S_.env});
  return vm.createContext ({$, Cons, Descending, List, Nil, R, S, Sum});
}) ();

//    toOutputMarkup :: String -> Html
const toOutputMarkup =
def ('toOutputMarkup')
    ({})
    ([$.String, Html.Type])
    (pipe ([encase (code => vm.runInContext (code,
                                             $context,
                                             {displayErrors: false})),
            either (pipe ([prop ('message'),
                           concat ('! '),
                           replace (/^$/gm) (ZERO_WIDTH_SPACE),
                           Html.encode,
                           Just,
                           el ('div') ({'class': 'output',
                                        'data-error': 'true'})]))
                   (pipe ([show,
                           Html.encode,
                           Just,
                           el ('div') ({'class': 'output'})]))]));

//    doctestsToMarkup :: String -> Html
const doctestsToMarkup =
def ('doctestsToMarkup')
    ({})
    ([$.String, Html.Type])
    (pipe ([matchAll (/^> .*(?:\n[.] .*)*/gm),
            map (prop ('match')),
            map (replace (/\[\n[.] */g) ('[')),
            map (replace (/,\n[.] \]/g) (']')),
            map (replace (/^../gm) ('')),
            map (replace (/^ +/gm) (' ')),
            map (replace (/\n/g) ('')),
            map (replace (/^global[.]/) ('const ')),
            map (lift2 (on (concat) (wrap (Html ('    ')) (Html ('\n'))))
                       (toInputMarkup)
                       (toOutputMarkup)),
            map (wrap (Html ('  <form>\n')) (Html ('  </form>\n'))),
            reduce (concat) (empty (Html)),
            wrap (Html ('<div class="examples">\n')) (Html ('</div>\n'))]));

//    syntax :: String -> RegExp -> (String -> Html) -> String -> Html
const syntax =
def ('syntax')
    ({})
    ([$.String, $.RegExp, $.Fn ($.String) (Html.Type), $.String, Html.Type])
    (className => pattern => f => s =>
       prop ('html')
            (reduce (({highlight, html}) => s => ({
                       highlight: !highlight,
                       html: concat (html)
                                    ((highlight ? spanClass (className) : f) (s)),
                     }))
                    ({highlight: false, html: empty (Html)})
                    (s.split (pattern))));

//    highlightChunk :: String -> Html
const highlightChunk =
def ('highlightChunk')
    ({})
    ([$.String, Html.Type])
    (syntax ('keyword')
            (/\b(const|else|function|if|instanceof|new|return|this)\b/)
            (syntax ('boolean-literal')
                    (/\b(false|true)\b/)
                    (syntax ('number-literal')
                            (/\b([0-9]+(?:[.][0-9]+)?)\b/)
                            (Html.encode))));

//    highlight :: Html -> Html
const highlight =
def ('highlight')
    ({})
    ([Html.Type, Html.Type])
    (_input => {
       const input = Html.decode (_input);
       let output = empty (Html);
       let chunk = '';
       const $ctx = [];
       const pop = () => { chunk = ''; $ctx.pop (); };
       for (let consumed, idx = 0; idx < input.length; idx += consumed.length) {
         const c = input.charAt (idx);
         const cc = input.slice (idx, idx + 2);
         const ctx = $ctx[$ctx.length - 1];
         if (ctx === '//') {
           if (c === '\n') {
             output = wrap (output)
                           (Html.encode (consumed = c))
                           (spanClass ('comment') (chunk));
             pop ();
           } else {
             chunk += consumed = c;
           }
         } else if (ctx === "'" || ctx === '"') {
           if (c === ctx) {
             output = concat (output)
                             (spanClass ('string-literal')
                                        (chunk + (consumed = c)));
             pop ();
           } else if (c === '\\') {
             chunk += consumed = cc;
           } else {
             chunk += consumed = c;
           }
         } else if (ctx === '`') {
           if (c === ctx) {
             output = concat (output)
                             (spanClass ('template-literal')
                                        (chunk + (consumed = c)));
             pop ();
           } else if (cc === '${') {
             output = wrap (output)
                           (spanClass ('punctuation') (consumed = cc))
                           (spanClass ('template-literal') (chunk));
             chunk = '';
             $ctx.push (cc);
           } else if (c === '\\') {
             chunk += consumed = cc;
           } else {
             chunk += consumed = c;
           }
         } else if (ctx === '${') {
           if (c === '}') {
             output = wrap (output)
                           (spanClass ('punctuation') (consumed = c))
                           (highlightChunk (chunk));
             pop ();
           } else {
             chunk += consumed = c;
           }
         } else if (cc === '//') {
           output = concat (output) (highlightChunk (chunk));
           $ctx.push (chunk = consumed = cc);
         } else if (c === "'" || c === '"' || c === '`') {
           output = concat (output) (highlightChunk (chunk));
           $ctx.push (chunk = consumed = c);
         } else {
           chunk += consumed = c;
         }
       }
       return concat (output) (highlightChunk (chunk));
     });

//    generate :: String -> Html
const generate =
def ('generate')
    ({})
    ([$.String, Html.Type])
    (pipe ([replace (regex ('gm') ('^(#{1,6}) <span id="([^"]*)">‚ùë (.*)</span>$'))
                    (($0, $1, $2, $3) => `<h${$1.length} id="${$2}">${$3}</h${$1.length}>`),
            replace (regex ('gm') ('^#### <a name="(.*)" href="(.*)">`(.*)`</a>$'))
                    (($0, $1, $2, $3) => Html.unwrap (headingToMarkup ($1) ($2) ($3))),
            replace (regex ('gm') ('^```javascript\\n(> [^]*?)^```\\n'))
                    (($0, $1) => Html.unwrap (doctestsToMarkup ($1))),
            s => marked (s, {}),
            replace (regex ('g') (ZERO_WIDTH_SPACE)) (''),
            replace (/&#39;/g) ("'"),
            replace (/&gt;/g) ('>'),
            replace (regex ('gm') ('(?!^)(?=</code></pre>)')) ('\n'),
            replace (regex ('g') ('(<pre><code class="language-javascript">)([^]*?)(?=</code></pre>)'))
                    (($0, $1, $2) => $1 + Html.unwrap (highlight (Html ($2)))),
            replace (regex ('gm') ('</code></pre>(?!$)')) ($0 => $0 + '\n'),
            replace (regex ('g') ('<(h[2-6]) id="([^"]*)">(.*)</\\1>\n*'))
                    ('<a class="pilcrow $1" href="#$2">' + PILCROW_SIGN + '</a>\n' +
                     '<$1 id="$2">$3</$1>\n'),
            Html]));

//    readFile :: String -> Future String String
const readFile =
def ('readFile')
    ({})
    ([$.String, $Future ($.String) ($.String)])
    (filename =>
       mapLeft (prop ('message'))
               (node (curry3 (fs.readFile) (filename) ('utf8'))));

//    writeFile :: String -> String -> Future String String
const writeFile =
def ('writeFile')
    ({})
    ([$.String, $.String, $Future ($.String) ($.String)])
    (filename => s =>
       bimap (prop ('message'))
             (K (filename))
             (node (curry3 (fs.writeFile) (filename) (s))));

//    field :: Type -> String -> Object -> Either String a
const field =
def ('field')
    ({})
    ([$.Type, $.String, $.Object, $.Either ($.String) (a)])
    (type => name => record =>
       maybe (Left (`Invalid "${name}"`))
             (Right)
             (get (is (type)) (name) (record)));

//    customize :: String -> Future String (String -> Future String String)
const customize =
def ('customize')
    ({})
    ([$.String,
      $Future ($.String) ($.Fn ($.String) ($Future ($.String) ($.String)))])
    (pipe ([readFile,
            map (splitOnRegex (/\n={79}\n\n/g)),
            chain (ifElse (compose (equals (2)) (prop ('length')))
                          (resolve)
                          (K (reject ('Expected exactly one separator')))),
            map (([existing, replacement]) =>
                   s => s.includes (existing) ?
                        resolve (replace (existing) (replacement) (s)) :
                        reject ('Substring not found:\n\n' + existing))]));

//    readme :: String -> Future String String
const readme =
def ('readme')
    ({})
    ([$.String, $Future ($.String) ($.String)])
    (pipe ([readFile,
            ap (customize ('custom/preamble.md')),
            join,
            ap (customize ('custom/sponsors.md')),
            join,
            ap (customize ('custom/type-error.md')),
            join,
            ap (customize ('custom/type-checking-sanctuary.md')),
            join,
            ap (customize ('custom/type-checking-ramda.md')),
            join,
            ap (customize ('custom/split-on-regex.md')),
            join,
            map (generate),
            map (Html.unwrap),
            map (concat ('\n')),
            map (replace (/\n$/) (''))]));

//    Heading :: Type
const Heading = $.RecordType ({
  level: $.PositiveInteger,
  id: $.String,
  html: Html.Type,
  subheads: $.Array ($.NullaryType ('Heading')
                                   ('')
                                   ([])
                                   (x => $.test ([]) (Heading) (x))),
});

//    tocListItem :: Heading -> Html
const tocListItem =
def ('tocListItem')
    ({})
    ([Heading, Html.Type])
    (function recur({level, id, html, subheads}) {
       const a = el ('a')
                    ({href: '#' + id})
                    (Just (Html (Html.unwrap (html)
                                 .replace (/<a [^>]*>([^<]*)<[/]a>/g,
                                           ($0, $1, idx) =>
                                             when (K (idx === '<code>'.length))
                                                  (wrap ('<b>') ('</b>'))
                                                  ($1)))));
       return Html.indent (4) (reduce (concat) (empty (Html)) (join (join ([
         [[Html ('<li>\n')]],
         subheads.length === 0 ?
           [[Html ('  '), a, Html ('\n')]] :
         level < 3 ?
           [[Html ('  '), a, Html ('\n')],
            [Html ('  <ul>\n')],
            map (recur) (subheads),
            [Html ('  </ul>\n')]] :
         // else
           [[Html ('  <details>\n')],
            [Html ('    <summary>'), a, Html ('</summary>\n')],
            [Html ('    <ul>\n')],
            map (compose (Html.indent (2)) (recur)) (subheads),
            [Html ('    </ul>\n')],
            [Html ('  </details>\n')]],
         [[Html ('</li>\n')]],
       ]))));
     });

//    toc :: String -> Html
const toc =
def ('toc')
    ({})
    ([$.String, Html.Type])
    (pipe ([matchAll (/<(h[1-6]) id="([^"]*)">(.*)<[/]\1>/g),
            map (prop ('groups')),
            map (map (fromJust)),
            reduce (heading => ([tagName, id, s]) => {
                      const level = Number (replace ('h', '', tagName));
                      for (let subheads = heading.subheads;
                           true;
                           subheads = subheads[subheads.length - 1].subheads) {
                        if (subheads.length === 0 ||
                            subheads[0].level === level) {
                          subheads.push ({level, id, html: Html (s), subheads: []});
                          return heading;
                        }
                      }
                    })
                   ({level: 1, id: '', html: empty (Html), subheads: []}),
            prop ('subheads'),
            map (tocListItem),
            reduce (concat) (empty (Html)),
            wrap (Html ('  <ul id="toc">\n'))
                 (Html ('  </ul>')),
            Html.indent (2),
            concat (Html ('\n'))]));

//    toDocument :: String -> String -> String -> Html
const toDocument =
def ('toDocument')
    ({})
    ([$.String, $.String, $.String, Html.Type])
    (version => tagline => content => Html (`<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Sanctuary</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Code:400,500,700&display=swap">
  <link rel="stylesheet" href="style.css">
  <link rel="shortcut icon" href="favicon.png">
  <link rel="mask-icon" href="mask-icon.svg" color="#080">
</head>
<body spellcheck="false">
  <div id="css-header">
    <p>
      Join the Sanctuary community on
      <a href="https://github.com/sanctuary-js/sanctuary">GitHub</a>,
      <a href="https://gitter.im/sanctuary-js/sanctuary">Gitter</a>, and
      <a href="https://stackoverflow.com/questions/tagged/sanctuary">Stack Overflow</a>
    </p>
  </div>
  <div id="css-main">
    <h1 id="sanctuary">Sanctuary <small>v${version}</small></h1>
    <p id="tagline">${tagline}</p>
${Html.unwrap (toc (content))}
${content}
  </div>
  <script src="vendor/ramda.js"></script>
  <script src="vendor/sanctuary-bundle.js"></script>
  <script src="vendor/sanctuary-descending.js"></script>
  <script src="vendor/sanctuary-identity.js"></script>
  <script src="adt/Html.js"></script>
  <script src="adt/List.js"></script>
  <script src="adt/Sum.js"></script>
  <script src="env.js"></script>
  <script>
    window.type = window.sanctuaryTypeIdentifiers;
    window.Z = window.sanctuaryTypeClasses;
    window.$ = window.sanctuaryDef;
    window.Descending = window.sanctuaryDescending;
    window.Identity = window.sanctuaryIdentity;
    window.Nil = window.List.Nil;
    window.Cons = window.List.Cons;
    window.S = window.sanctuary.create({checkTypes: true, env: env});
    window.S.env = window.sanctuary.env;
    window.def = $.create({checkTypes: true, env: env});
  </script>
  <script src="behaviour.js"></script>
</body>
</html>
`));

//    program :: Array String -> Future String String
const program = pipe ([
  array (reject ('Missing command-line argument'))
        (compose (K) (resolve)),
  map (curry2 (path.join)),
  chain (path =>
           flip (pipe) ('package.json') ([
             path,
             readFile,
             chain (compose (mapLeft (prop ('message')))
                            (Future.encase (JSON.parse))),
             lift2 (lift3 (toDocument))
                   (chain (compose (eitherToFuture)
                                   (field ($.String) ('version'))))
                   (chain (compose (eitherToFuture)
                                   (field ($.String) ('description')))),
             T (readme (path ('README.md'))),
           ])),
  map (Html.unwrap),
  chain (writeFile ('index.html')),
]);

//    failure :: String -> Undefined
const failure = s => {
  process.stderr.write (`${red}${s}${reset}\n`);
  process.exit (1);
};

//    success :: String -> Undefined
const success = s => {
  process.stdout.write (`${green}Successfully created ${s}${reset}\n`);
  process.exit (0);
};

fork (failure) (success) (program (process.argv.slice (2)));
